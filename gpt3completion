#!/usr/bin/python3
import os
import sys
import itertools as it
from builtins import Exception
import openai
from argparse import Namespace, ArgumentParser
from tqdm import tqdm

openai.api_key = os.environ['OPENAI_API_KEY']

conf = Namespace()
conf.prompt = ""

conf.number = 10
conf.maxTokens = 12
conf.T = 1
conf.topP = 1
conf.bestOf = 1
conf.addTemp0Sample = False
conf.engine = "text-davinci-002"
conf.stop =  "" # [")", "\n"] # "\n" # "" # ["\n", "."] #
conf.reflect = False
conf.sort = False
conf.frequency_penalty = 0
conf.presence_penalty = 0
conf.promptFile = None
conf.outDir = None


conf.writeFile = True
conf.wrapLines = False
conf.enumerateAnswers = True
conf.fileNameLength = 72
conf.columns = 50
conf.enumSep = ') '
conf.countFrom = 1
conf.noSep = True
conf.promptLineComment = '#'  # expose at command line
conf.promptEndComment = '###'
nonFileNameChars = '\"\',./;:*?!<>|&$\\' # todo


def main(argv):
    parser = ArgumentParser(description='OpenAI GPT-3 - query one or more completions for a prompt',
                            exit_on_error=False)
    add = parser.add_argument
    add('prompt',                    nargs='?',              default=conf.prompt,      type=str, help='Prompt for GPT-3, text to be completed')
    add('-n', '--n-completions',     dest='number',          default=conf.number,      type=int, help='Number of completions to request')
    add('-o', '--out-dir',           dest='outDir',          default=conf.outDir,      type=str, help='Prompt fÃ¼r GPT-3, text to be completed')
    add('-t', '--T', '--temperature', dest='T',              default=conf.T,           type=int, help='Temperature from 0 deterministic to 1')
    add('-r', '--reflect',           dest='reflect',         default=conf.reflect,     action='store_true', help='todo: Reflect to find the best answers')
    add('-f', '--prompt-file',       dest='promptFile',      default=conf.promptFile,  type=str, help='todo: File with the input prompt, alternative to giving it as arg itself')
    add('-b', '--best-of',           dest='bestOf',          default=conf.bestOf,      type=int, help='best_of parameter of the query')
    add('-p', '--top-p',             dest='topP',            default=conf.topP,        type=int, help='top_p parameter of the query')
    add('-a', '--add-T-0', dest='addTemp0Sample',            default=conf.addTemp0Sample,        help='For multiple answers, if T is not 0, add extra answer for it')
    add('-s', '--sort',              dest='sort',            default=conf.sort,        action='store_true', help='sort multiple results')
    #todo add outDir

    args = parser.parse_args(argv[1:])
    prompt = args.prompt

    #todo use __dict__:
    conf.outDir =      args.outDir
    conf.T = args.T
    conf.addTemp0Sample = args.addTemp0Sample
    conf.reflect =     args.reflect
    conf.promptFile =  args.promptFile
    conf.bestOf =      args.bestOf
    conf.topP =        args.topP
    conf.sort =        args.sort
    conf.sweep =       [] # todo args.sweep

    prompt = prompt.strip()
    if not prompt and conf.promptFile:
        prompt, sweep = readPromptFile(conf.promptFile)

    assert prompt
    openai_completion(prompt, args.number, sweep)


def openai_completion(prompt, n, sweep=[]):
    answers = gpt3CompletionsSweep(prompt, n, T=conf.T, sweep=sweep)
    if conf.sort:
        answers.sort()
    if conf.addTemp0Sample and conf.T != 0 and n > 1 and len(sweep) <= 1:
        T0Answer = gpt3Completions(prompt, n=1, T=0)[0]
        answers.append("# T = 0:\n   " + T0Answer)
    writeAnswers(prompt, answers, sweep)


def gpt3CompletionsSweep(prompt, n, T=conf.T, sweep=[]):
    if sweep:
        prompts = [prompt % (variant or ()) for variant in sweep]
    else:
        prompts = [prompt]

    promptsProgress = tqdm(prompts, ncols=120)
    completions = []
    for prompt in promptsProgress:
        promptLabel, *_ = prompt.split('\n', 1)
        promptsProgress.set_description(f"{promptLabel[:50]} ({n})")
        completion = gpt3Completions(prompt, n, T, logprobs=20)
        completions += completion
    return completions


def gpt3YesOrNo(prompt, n, T=conf.T):
    gpt3Completions(prompt, n, T=conf.T, logprobs=5)


def gpt3Completions(prompt, n, T=conf.T, logprobs=0):
    bestOfArg = {'best_of': conf.bestOf} if conf.bestOf > 1 else {}
    if not prompt:
        raise Exception("empty prompt")
    responses = openai.Completion.create(
        n=n, engine=conf.engine, prompt=prompt, temperature=T,
        max_tokens=conf.maxTokens, top_p=conf.topP, **bestOfArg,
        frequency_penalty=conf.frequency_penalty,
        presence_penalty=conf.presence_penalty,
        stop=conf.stop,
        logprobs=logprobs,
        #echo=True
    )
    return decodeResponses(responses)


def decodeResponses(responses):
    # print(responses)
    answers = []
    for choice in responses['choices']:
        print(choice.text.__repr__())
        answer = choice.text.replace('\n\n', '\n')
        answer += '[...]' if len(choice.logprobs.tokens) > 1 and choice.finish_reason == "length" else ''
        answers.append(answer)
    return answers


def gpt3IteratedCompletion(prompt, iterations, T=conf.T):
    print(f"{len(prompt)=}")
    prompt += gpt3Completions(prompt, 1, T)[0]
    iterations -= 1
    if not iterations:
        return [prompt]
    return gpt3IteratedCompletion(prompt, iterations, T=conf.T)


def numberedFile(repeatedFileName, ext):
    i = 1
    newFileName = repeatedFileName + ext
    while os.path.exists(newFileName):
        newFileName = f'{repeatedFileName}-{i}{ext}'
        i += 1
    return newFileName


def prefixEnumerationItems(texts: list[str], sweep=None):
    if len(texts) == 1:
        return texts
    results: list[str] = []
    n = len(texts)/(len(sweep) if sweep else 1)
    for i, text in enumerate(texts):
        if text.startswith('\n\n'):
            text = text[2:]
        if text.startswith('\n'):
            text = text[1:]
        sep = '\n' if not conf.noSep and (text.count('\n') or sweep) else ' '
        sweepText = str(sweep[int(i / n)]) if sweep else ''
        step = "Variant '" + sweepText + "':\n" if sweep and sweepText and not i % n else ''
        results += ["%s%2d%s%s%s" % (step, (i + conf.countFrom), conf.enumSep, sep, text)]
    return results


def readPromptFile(filePath):
    isNotComment = lambda l: not l.startswith('#')
    isNotEndComment = lambda s: not s.startswith(conf.promptEndComment)

    with open(filePath) as file:
        lines = file.readlines()

        if lines[0].startswith('# GPT-3'):
            parseMetaLine(lines[0])
            lines = lines[1:]
            isResultFile = True
        else:
            isResultFile = False

        if lines[0].startswith("#sweep") or lines[0].startswith("#variants:"):
            sweep = parseSweep(lines[0])
            lines = lines[1:]
        else:
            sweep = []

        lines = it.takewhile(isNotEndComment, lines)
        lines = filter(isNotComment, lines)

        text = str.join('', lines)
        if text[-1] == '\n':
            text = text[:-1]
        if isResultFile:
            prompt, *completion = text.split('"\n\n', 1)
        else:
            prompt = text
        return prompt, sweep


def parseSweep(sweepLine):
    if not sweepLine.count(':'):
        raise ValueError("sweep without ':'", sweepLine)
    command, line = sweepLine.split(':', 1)
    command = command.strip().lower()

    if command == '#variants':
        return list(map(str.strip, line.split(',')))
    if command == '#sweep':
        return list(eval(line))
    raise ValueError("Unknown sweep type. Use sweep: or variants:", command)


def parseMetaLine(metaLine):
    # first line leaving out "# GPT-3", leaving out engine name
    metaLine: list[str] = metaLine[8:-1].split()[1:]
    return dict([tuple(e.split(':')) for e in metaLine])


def metaLine(prompt, answers):
    n = len(answers)
    avgLen = round(sum(map(len, answers)) / n)
    return f"# GPT-3 {conf.engine} T:{conf.T} topP:{conf.topP} freqPen:{conf.frequency_penalty}" +\
           f" presPen:{conf.presence_penalty} bestOf:{conf.bestOf} stop:{conf.stop.__repr__()} sort:{conf.sort}" +\
           f" pLen:{len(prompt)} avgLen:{avgLen} n:{n} maxT:{conf.maxTokens}"


def writeAnswers(prompt, answers, sweep=None):
#    sweepText = "\n# " + str(len(sweep)) + ' ' + sweep.__repr__() if sweep else ""
    sweepText = f"\n# Sweep: {len(sweep)} {sweep.__repr__()}" if sweep else ""
    header = metaLine(prompt, answers) + sweepText + "\n\n\"" + prompt + "\"\n\n"
    if conf.enumerateAnswers:
        answers = prefixEnumerationItems(answers, sweep=sweep)
    output = header + str.join('\n', answers) + '\n'
    print(output)
    if conf.writeFile:
        filePath = textNamedFilePath(prompt)
        with open(filePath, "w") as file:
            file.write(output)


def textNamedFilePath(prompt):
    fileName = prompt[:conf.fileNameLength].translate(str.maketrans('\n', ' ', nonFileNameChars))
    filePath = numberedFile(f'{conf.outDir}/{fileName}', '.txt')
    if not os.path.exists(conf.outDir):
        os.mkdir(conf.outDir)
    return filePath


if __name__ == '__main__': main(sys.argv)
